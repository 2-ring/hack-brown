{
  "version": 3,
  "sources": ["../api.ts", "../compat/detect.ts", "../compat/storage.ts", "../compat/notifications.ts", "../compat/panel.ts", "../compat/action.ts", "../compat/polling.ts", "../background.ts"],
  "sourcesContent": ["import type { Session, CalendarEvent } from './types';\n\nconst API_URL = 'https://api.dropcal.ai';\n\n// Auth state is injected by the background script before each call\nlet _authToken: string | null = null;\n\nexport function setAuthToken(token: string | null): void {\n  _authToken = token;\n}\n\nfunction authHeaders(): Record<string, string> {\n  const headers: Record<string, string> = { 'Content-Type': 'application/json' };\n  if (_authToken) {\n    headers['Authorization'] = `Bearer ${_authToken}`;\n  }\n  return headers;\n}\n\nasync function handleResponse<T>(response: Response): Promise<T> {\n  if (!response.ok) {\n    const err = await response.json().catch(() => ({ error: response.statusText }));\n    throw new Error(err.error || `HTTP ${response.status}`);\n  }\n  return response.json();\n}\n\n// ===== Authenticated endpoints =====\n\nexport async function createTextSession(text: string): Promise<Session> {\n  const response = await fetch(`${API_URL}/sessions`, {\n    method: 'POST',\n    headers: authHeaders(),\n    body: JSON.stringify({ text }),\n  });\n  const data = await handleResponse<{ session: Session }>(response);\n  return data.session;\n}\n\nexport async function uploadImage(imageUrl: string): Promise<Session> {\n  const imageResponse = await fetch(imageUrl);\n  if (!imageResponse.ok) {\n    throw new Error(`Failed to fetch image: ${imageResponse.status}`);\n  }\n\n  const blob = await imageResponse.blob();\n  const urlPath = new URL(imageUrl).pathname;\n  const filename = urlPath.split('/').pop() || 'image.png';\n\n  const formData = new FormData();\n  formData.append('file', blob, filename);\n\n  const headers: Record<string, string> = {};\n  if (_authToken) {\n    headers['Authorization'] = `Bearer ${_authToken}`;\n  }\n\n  const response = await fetch(`${API_URL}/upload`, {\n    method: 'POST',\n    headers,\n    body: formData,\n  });\n  const data = await handleResponse<{ session: Session }>(response);\n  return data.session;\n}\n\nexport async function getSession(sessionId: string): Promise<Session> {\n  const response = await fetch(`${API_URL}/sessions/${sessionId}`, {\n    method: 'GET',\n    headers: authHeaders(),\n  });\n  const data = await handleResponse<{ session: Session }>(response);\n  return data.session;\n}\n\nexport async function getSessionEvents(\n  sessionId: string,\n): Promise<{ events: CalendarEvent[]; count: number }> {\n  const response = await fetch(`${API_URL}/sessions/${sessionId}/events`, {\n    method: 'GET',\n    headers: authHeaders(),\n  });\n  return handleResponse(response);\n}\n\n// Fetch the authenticated user's preferences (theme_mode, etc.)\nexport async function getUserPreferences(): Promise<{ theme_mode?: string }> {\n  const response = await fetch(`${API_URL}/auth/profile`, {\n    method: 'GET',\n    headers: authHeaders(),\n  });\n  const data = await handleResponse<{ user: { preferences?: { theme_mode?: string } } }>(response);\n  return data.user.preferences || {};\n}\n\n// Fetch full user profile (email, plan, preferences, etc.)\nexport async function getUserProfile(): Promise<{\n  email: string;\n  display_name: string | null;\n  photo_url: string | null;\n  plan: string;\n  primary_calendar_provider: string | null;\n  preferences: Record<string, any>;\n}> {\n  const response = await fetch(`${API_URL}/auth/profile`, {\n    method: 'GET',\n    headers: authHeaders(),\n  });\n  const data = await handleResponse<{ user: any }>(response);\n  return {\n    email: data.user.email,\n    display_name: data.user.display_name,\n    photo_url: data.user.photo_url,\n    plan: data.user.plan || 'free',\n    primary_calendar_provider: data.user.primary_calendar_provider,\n    preferences: data.user.preferences || {},\n  };\n}\n\n// Update user preferences (theme_mode, date_format)\nexport async function updateUserPreferences(prefs: {\n  theme_mode?: string;\n  date_format?: string;\n}): Promise<{ preferences: Record<string, any> }> {\n  const response = await fetch(`${API_URL}/auth/preferences`, {\n    method: 'PUT',\n    headers: authHeaders(),\n    body: JSON.stringify(prefs),\n  });\n  return handleResponse(response);\n}\n\n// Get all calendar providers\nexport async function getCalendarProviders(): Promise<{\n  providers: Array<{\n    provider: string;\n    email: string;\n    connected: boolean;\n    is_primary: boolean;\n  }>;\n}> {\n  const response = await fetch(`${API_URL}/calendar/provider/list`, {\n    method: 'GET',\n    headers: authHeaders(),\n  });\n  return handleResponse(response);\n}\n\n// Set primary calendar provider\nexport async function setPrimaryCalendarProvider(provider: string): Promise<void> {\n  const response = await fetch(`${API_URL}/calendar/provider/set-primary`, {\n    method: 'POST',\n    headers: authHeaders(),\n    body: JSON.stringify({ provider }),\n  });\n  await handleResponse(response);\n}\n\n// Disconnect a calendar provider\nexport async function disconnectCalendarProvider(provider: string): Promise<void> {\n  const response = await fetch(`${API_URL}/calendar/provider/disconnect`, {\n    method: 'POST',\n    headers: authHeaders(),\n    body: JSON.stringify({ provider }),\n  });\n  await handleResponse(response);\n}\n\n// Push events to the user's calendar provider\nexport async function pushEvents(\n  sessionId: string,\n  eventIds: string[],\n): Promise<{ success: boolean; message: string }> {\n  const response = await fetch(`${API_URL}/events/push`, {\n    method: 'POST',\n    headers: authHeaders(),\n    body: JSON.stringify({ event_ids: eventIds, session_id: sessionId }),\n  });\n  return handleResponse(response);\n}\n\n// Upload a file (from drop zone / file picker) as FormData\nexport async function uploadFile(\n  fileData: Uint8Array,\n  filename: string,\n  mimeType: string,\n): Promise<Session> {\n  const blob = new Blob([fileData], { type: mimeType });\n  const formData = new FormData();\n  formData.append('file', blob, filename);\n\n  const headers: Record<string, string> = {};\n  if (_authToken) {\n    headers['Authorization'] = `Bearer ${_authToken}`;\n  }\n\n  const response = await fetch(`${API_URL}/upload`, {\n    method: 'POST',\n    headers,\n    body: formData,\n  });\n  const data = await handleResponse<{ session: Session }>(response);\n  return data.session;\n}\n", "// Feature detection for cross-browser compatibility.\n// All branching in the compat layer uses these flags \u2014 never browser sniffing.\n\ndeclare const browser: typeof chrome | undefined;\n\nconst _chrome = globalThis.chrome;\n\n/** Firefox exposes `browser.*` with native Promise support */\nexport const hasNativeBrowserAPI = typeof browser !== 'undefined';\n\n/** The base API object \u2014 Firefox `browser` or Chrome/Safari `chrome` */\nexport const api: typeof chrome = hasNativeBrowserAPI\n  ? (browser as typeof chrome)\n  : _chrome;\n\n/** chrome.sidePanel (Chrome 114+) */\nexport const hasSidePanel =\n  typeof _chrome !== 'undefined' && 'sidePanel' in _chrome;\n\n/** browser.sidebarAction (Firefox) */\nexport const hasSidebarAction =\n  typeof browser !== 'undefined' &&\n  typeof (browser as any).sidebarAction?.open === 'function';\n\n/** chrome.storage.session (Chrome 102+, Firefox 115+) */\nexport const hasSessionStorage =\n  typeof _chrome !== 'undefined' &&\n  typeof _chrome.storage !== 'undefined' &&\n  'session' in _chrome.storage;\n\n/** chrome.notifications (not available in Safari extensions) */\nexport const hasNotifications =\n  typeof _chrome !== 'undefined' && 'notifications' in _chrome;\n\n/** chrome.action.openPopup() (Chrome 127+, Firefox 127+) */\nexport const hasOpenPopup =\n  typeof _chrome !== 'undefined' &&\n  typeof _chrome.action?.openPopup === 'function';\n\n/** chrome.alarms (all MV3 browsers) */\nexport const hasAlarms =\n  typeof _chrome !== 'undefined' && 'alarms' in _chrome;\n", "// Unified storage API with a fallback for browsers without chrome.storage.session.\n// Safari (older versions) lacks session storage \u2014 we emulate it by namespacing\n// keys in local storage with a \"__session:\" prefix and clearing on startup.\n\nimport { api, hasSessionStorage } from './detect';\n\nconst SESSION_PREFIX = '__session:';\n\n// Minimal interface for the storage methods we actually use.\n// Avoids fighting with chrome.storage.StorageArea's complex overloads.\nexport interface SimpleStorageArea {\n  get(keys: string | string[] | null, callback: (items: Record<string, any>) => void): void;\n  set(items: Record<string, any>, callback?: () => void): void;\n  remove(keys: string | string[], callback?: () => void): void;\n  clear(callback?: () => void): void;\n  onChanged: {\n    addListener(callback: (changes: Record<string, chrome.storage.StorageChange>, areaName?: string) => void): void;\n  };\n}\n\nfunction prefixKeys(keys: string | string[] | Record<string, any>): string[] {\n  if (typeof keys === 'string') return [`${SESSION_PREFIX}${keys}`];\n  if (Array.isArray(keys)) return keys.map((k) => `${SESSION_PREFIX}${k}`);\n  return Object.keys(keys).map((k) => `${SESSION_PREFIX}${k}`);\n}\n\nfunction prefixRecord(items: Record<string, any>): Record<string, any> {\n  const out: Record<string, any> = {};\n  for (const [k, v] of Object.entries(items)) {\n    out[`${SESSION_PREFIX}${k}`] = v;\n  }\n  return out;\n}\n\nfunction unprefixRecord(result: Record<string, any>): Record<string, any> {\n  const out: Record<string, any> = {};\n  for (const [k, v] of Object.entries(result)) {\n    if (k.startsWith(SESSION_PREFIX)) {\n      out[k.slice(SESSION_PREFIX.length)] = v;\n    }\n  }\n  return out;\n}\n\n// ===== Session fallback change listeners =====\n\ntype StorageChangeCallback = (\n  changes: Record<string, chrome.storage.StorageChange>,\n  areaName?: string,\n) => void;\n\nconst sessionFallbackListeners = new Set<StorageChangeCallback>();\nlet localChangeListenerInstalled = false;\n\nfunction ensureLocalChangeListener(): void {\n  if (localChangeListenerInstalled) return;\n  localChangeListenerInstalled = true;\n\n  api.storage.local.onChanged.addListener((changes) => {\n    if (sessionFallbackListeners.size === 0) return;\n\n    const sessionChanges: Record<string, chrome.storage.StorageChange> = {};\n    let hasChanges = false;\n\n    for (const [key, change] of Object.entries(changes)) {\n      if (key.startsWith(SESSION_PREFIX)) {\n        sessionChanges[key.slice(SESSION_PREFIX.length)] = change;\n        hasChanges = true;\n      }\n    }\n\n    if (hasChanges) {\n      for (const listener of sessionFallbackListeners) {\n        listener(sessionChanges, 'session');\n      }\n    }\n  });\n}\n\n// ===== Fallback implementation =====\n\nconst sessionFallback: SimpleStorageArea = {\n  get(keys, callback) {\n    const prefixed = keys === null ? null : prefixKeys(keys);\n    api.storage.local.get(prefixed, (result) => {\n      callback(unprefixRecord(result));\n    });\n  },\n\n  set(items, callback) {\n    if (callback) {\n      api.storage.local.set(prefixRecord(items), callback);\n    } else {\n      api.storage.local.set(prefixRecord(items));\n    }\n  },\n\n  remove(keys, callback) {\n    const prefixed = prefixKeys(keys);\n    if (callback) {\n      api.storage.local.remove(prefixed, callback);\n    } else {\n      api.storage.local.remove(prefixed);\n    }\n  },\n\n  clear(callback) {\n    api.storage.local.get(null, (all) => {\n      const sessionKeys = Object.keys(all).filter((k) => k.startsWith(SESSION_PREFIX));\n      if (sessionKeys.length > 0) {\n        if (callback) {\n          api.storage.local.remove(sessionKeys, callback);\n        } else {\n          api.storage.local.remove(sessionKeys);\n        }\n      } else {\n        callback?.();\n      }\n    });\n  },\n\n  onChanged: {\n    addListener(callback: StorageChangeCallback) {\n      ensureLocalChangeListener();\n      sessionFallbackListeners.add(callback);\n    },\n  },\n};\n\n/** Clear ephemeral session keys on service worker startup (mimics session storage behavior). */\nexport function clearSessionFallback(): void {\n  if (!hasSessionStorage) {\n    sessionFallback.clear();\n  }\n}\n\n// ===== Exported storage object =====\n\n// Wrap the real chrome.storage.session to match our SimpleStorageArea interface.\n// This avoids type issues with chrome's complex overloaded signatures.\nfunction wrapNativeSession(): SimpleStorageArea {\n  const native = api.storage.session;\n  return {\n    get(keys, callback) { native.get(keys, callback); },\n    set(items, callback) { if (callback) native.set(items, callback); else native.set(items); },\n    remove(keys, callback) { if (callback) native.remove(keys, callback); else native.remove(keys); },\n    clear(callback) { if (callback) native.clear(callback); else native.clear(); },\n    onChanged: native.onChanged,\n  };\n}\n\nexport const storage = {\n  local: api.storage.local,\n  session: hasSessionStorage ? wrapNativeSession() : sessionFallback,\n  onChanged: api.storage.onChanged,\n};\n", "// Cross-browser notification abstraction.\n// Safari extensions lack chrome.notifications \u2014 gracefully no-ops there.\n\nimport { api, hasNotifications } from './detect';\n\nexport const notifications = {\n  create(\n    id: string,\n    options: { type: 'basic'; iconUrl: string; title: string; message: string },\n  ): void {\n    if (hasNotifications) {\n      api.notifications.create(id, options);\n    }\n  },\n\n  onClicked: hasNotifications\n    ? api.notifications.onClicked\n    : { addListener: (_cb: (id: string) => void) => {} },\n};\n", "// Unified side panel adapter.\n// Chrome \u2192 chrome.sidePanel.\n// Firefox \u2192 browser.sidebarAction.\n// Safari \u2192 browser.sidebarAction (Safari supports it in MV3).\n\nimport { api, hasSidePanel, hasSidebarAction } from './detect';\nimport { storage } from './storage';\n\ndeclare const browser: typeof chrome | undefined;\n\nexport interface PanelAdapter {\n  open(options: { windowId?: number; sessionId?: string }): Promise<void>;\n  isSupported: boolean;\n}\n\nfunction chromeSidePanel(): PanelAdapter {\n  return {\n    isSupported: true,\n    async open({ windowId, sessionId }) {\n      if (sessionId) {\n        await new Promise<void>((resolve) => {\n          storage.session.set({ sidebarSessionId: sessionId }, resolve);\n        });\n      }\n      if (windowId) {\n        await (api.sidePanel as any).open({ windowId });\n      }\n    },\n  };\n}\n\nfunction firefoxSidebar(): PanelAdapter {\n  return {\n    isSupported: true,\n    async open({ sessionId }) {\n      // sidebarAction.open() MUST be called before any await \u2014 Firefox loses\n      // the user-action context after an async gap (Bugzilla #1800401).\n      await (browser as any).sidebarAction.open();\n      if (sessionId) {\n        storage.session.set({ sidebarSessionId: sessionId });\n      }\n    },\n  };\n}\n\nexport const panel: PanelAdapter = hasSidePanel\n  ? chromeSidePanel()\n  : firefoxSidebar();\n", "// Badge and popup action abstraction.\n// chrome.action.openPopup() is Chrome 127+ / Firefox 127+ only \u2014 degrades to no-op.\n\nimport { api, hasOpenPopup } from './detect';\n\nexport const action = {\n  setBadgeText(details: { text: string }): void {\n    api.action.setBadgeText(details);\n  },\n\n  setBadgeBackgroundColor(details: { color: string }): void {\n    api.action.setBadgeBackgroundColor(details);\n  },\n\n  /** Try to programmatically open the popup. No-ops on browsers that don't support it. */\n  async tryOpenPopup(): Promise<void> {\n    if (hasOpenPopup) {\n      try {\n        await api.action.openPopup();\n      } catch {\n        // Gesture required or other restriction \u2014 silently ignore\n      }\n    }\n  },\n};\n", "// Alarm-based polling that survives service worker restarts.\n// Falls back to setInterval for contexts where alarms aren't available\n// (e.g., if permission is missing), but alarms are the primary mechanism.\n\nimport { api, hasAlarms } from './detect';\n\nconst ALARM_PREFIX = 'poll:';\nconst POLL_PERIOD_MINUTES = 1 / 30; // ~2 seconds (Chrome enforces 30s min in production)\n// Chrome enforces a minimum of 30s for alarm periods. For faster polling,\n// we use a single alarm as a keep-alive and do rapid polling via setTimeout\n// within the alarm handler. The alarm ensures the service worker stays alive.\n\nconst RAPID_POLL_MS = 2000;\nconst KEEPALIVE_ALARM = 'poll-keepalive';\n\ntype PollCallback = (sessionId: string) => Promise<void>;\n\nlet pollCallback: PollCallback | null = null;\nlet activePolls = new Set<string>();\nlet rapidTimers = new Map<string, ReturnType<typeof setTimeout>>();\n\n/** Register the callback that executes on each poll tick. Call once at startup. */\nexport function onPollTick(callback: PollCallback): void {\n  pollCallback = callback;\n\n  if (hasAlarms) {\n    api.alarms.onAlarm.addListener((alarm) => {\n      if (alarm.name === KEEPALIVE_ALARM) {\n        // Keepalive fired \u2014 the rapid setTimeout timers do the actual work.\n        // This just ensures the service worker stays alive.\n      }\n    });\n  }\n}\n\n/** Start polling a session. */\nexport function startPolling(sessionId: string): void {\n  activePolls.add(sessionId);\n  ensureKeepalive();\n  scheduleRapidPoll(sessionId);\n}\n\n/** Stop polling a session. */\nexport function stopPolling(sessionId: string): void {\n  activePolls.delete(sessionId);\n  const timer = rapidTimers.get(sessionId);\n  if (timer) {\n    clearTimeout(timer);\n    rapidTimers.delete(sessionId);\n  }\n  if (activePolls.size === 0) {\n    clearKeepalive();\n  }\n}\n\n/** Stop all active polls. */\nexport function stopAllPolling(): void {\n  for (const id of activePolls) {\n    const timer = rapidTimers.get(id);\n    if (timer) clearTimeout(timer);\n  }\n  activePolls.clear();\n  rapidTimers.clear();\n  clearKeepalive();\n}\n\n/** Check if a session is currently being polled. */\nexport function isPolling(sessionId: string): boolean {\n  return activePolls.has(sessionId);\n}\n\nfunction scheduleRapidPoll(sessionId: string): void {\n  if (!activePolls.has(sessionId)) return;\n\n  const tick = async () => {\n    if (!activePolls.has(sessionId) || !pollCallback) return;\n    try {\n      await pollCallback(sessionId);\n    } catch {\n      // Error handling is in the callback\n    }\n    // Schedule next tick if still active\n    if (activePolls.has(sessionId)) {\n      rapidTimers.set(sessionId, setTimeout(tick, RAPID_POLL_MS));\n    }\n  };\n\n  // First tick immediately\n  tick();\n}\n\nfunction ensureKeepalive(): void {\n  if (hasAlarms) {\n    // Create a periodic alarm to keep the service worker alive.\n    // Chrome minimum is 30s for periodInMinutes, so we use delayInMinutes of 0.5\n    // and re-create on each fire.\n    api.alarms.get(KEEPALIVE_ALARM, (alarm) => {\n      if (!alarm) {\n        api.alarms.create(KEEPALIVE_ALARM, { periodInMinutes: 0.5 });\n      }\n    });\n  }\n}\n\nfunction clearKeepalive(): void {\n  if (hasAlarms) {\n    api.alarms.clear(KEEPALIVE_ALARM);\n  }\n}\n", "import type { ActiveJob, AuthState, SessionRecord, SessionHistory } from './types';\nimport {\n  setAuthToken,\n  createTextSession,\n  uploadImage,\n  getSession,\n  getSessionEvents,\n  getUserPreferences,\n  getUserProfile,\n  updateUserPreferences,\n  getCalendarProviders,\n  setPrimaryCalendarProvider,\n  disconnectCalendarProvider,\n  pushEvents,\n} from './api';\nimport {\n  api,\n  storage,\n  clearSessionFallback,\n  notifications,\n  action,\n  panel,\n  onPollTick,\n  startPolling,\n  stopPolling,\n} from './compat';\n\nconst MAX_POLL_DURATION_MS = 5 * 60 * 1000;\nconst MAX_HISTORY_SESSIONS = 10;\nconst CONTEXT_MENU_ID = 'send-to-dropcal';\nconst DROPCAL_URL = 'https://dropcal.ai';\nconst FEEDBACK_EXPIRY_MS = 24 * 60 * 60 * 1000;\n\n// Clear emulated session storage on startup (no-ops if real session storage exists)\nclearSessionFallback();\n\n// ===== Auth State Management =====\n\nasync function getAuth(): Promise<AuthState | null> {\n  return new Promise((resolve) => {\n    storage.local.get('auth', (result) => {\n      resolve(result.auth || null);\n    });\n  });\n}\n\nasync function setAuth(auth: AuthState): Promise<void> {\n  await new Promise<void>((resolve) => {\n    storage.local.set({ auth }, resolve);\n  });\n  setAuthToken(auth.accessToken);\n  fetchAndStoreTheme();\n}\n\nasync function fetchAndStoreTheme(): Promise<void> {\n  try {\n    const prefs = await getUserPreferences();\n    const themeMode = prefs.theme_mode || 'auto';\n    storage.local.set({ themeMode });\n  } catch {\n    // If preferences fetch fails (e.g. token expired), default to auto\n  }\n}\n\nasync function clearAuth(): Promise<void> {\n  await new Promise<void>((resolve) => {\n    storage.local.remove(['auth', 'themeMode'], resolve);\n  });\n  setAuthToken(null);\n}\n\nasync function ensureAuth(): Promise<boolean> {\n  const auth = await getAuth();\n  if (!auth) return false;\n\n  // Proactively clear expired tokens (with 60s buffer)\n  if (auth.expiresAt && Date.now() / 1000 > auth.expiresAt - 60) {\n    await clearAuth();\n    return false;\n  }\n\n  setAuthToken(auth.accessToken);\n  return true;\n}\n\n// ===== Session History Management =====\n\nasync function getHistory(): Promise<SessionHistory> {\n  return new Promise((resolve) => {\n    storage.local.get('sessionHistory', (result) => {\n      resolve(result.sessionHistory || { sessions: [] });\n    });\n  });\n}\n\nasync function saveHistory(history: SessionHistory): Promise<void> {\n  history.sessions = history.sessions.slice(0, MAX_HISTORY_SESSIONS);\n  await new Promise<void>((resolve) => {\n    storage.local.set({ sessionHistory: history }, resolve);\n  });\n  syncBadge();\n}\n\nasync function addSessionRecord(record: SessionRecord): Promise<void> {\n  const history = await getHistory();\n  history.sessions = history.sessions.filter((s) => s.sessionId !== record.sessionId);\n  history.sessions.unshift(record);\n  await saveHistory(history);\n}\n\nasync function updateSessionRecord(\n  sessionId: string,\n  updates: Partial<SessionRecord>,\n): Promise<void> {\n  const history = await getHistory();\n  const idx = history.sessions.findIndex((s) => s.sessionId === sessionId);\n  if (idx !== -1) {\n    history.sessions[idx] = { ...history.sessions[idx], ...updates };\n    await saveHistory(history);\n  }\n}\n\n// ===== Notification Queue =====\n// Tracks session IDs that need the user's attention (completion order).\n\nasync function getNotificationQueue(): Promise<string[]> {\n  return new Promise((resolve) => {\n    storage.local.get('notificationQueue', (result) => {\n      resolve(result.notificationQueue || []);\n    });\n  });\n}\n\nasync function saveNotificationQueue(queue: string[]): Promise<void> {\n  await new Promise<void>((resolve) => {\n    storage.local.set({ notificationQueue: queue }, resolve);\n  });\n  syncBadge();\n}\n\nasync function pushNotification(sessionId: string): Promise<void> {\n  const queue = await getNotificationQueue();\n  if (!queue.includes(sessionId)) {\n    queue.push(sessionId);\n    await saveNotificationQueue(queue);\n  }\n}\n\nasync function removeNotification(sessionId: string): Promise<void> {\n  const queue = await getNotificationQueue();\n  await saveNotificationQueue(queue.filter((id) => id !== sessionId));\n}\n\n// ===== Context Menu Setup =====\n\napi.runtime.onInstalled.addListener(() => {\n  api.contextMenus.create({\n    id: CONTEXT_MENU_ID,\n    title: 'Send to DropCal',\n    contexts: ['selection', 'image'],\n  });\n\n  // Migrate Phase 1 activeJob \u2192 sessionHistory if present\n  migratePhase1Job();\n});\n\nasync function migratePhase1Job(): Promise<void> {\n  return new Promise((resolve) => {\n    storage.session.get('activeJob', (result) => {\n      const job = result.activeJob as ActiveJob | undefined;\n      if (job && job.sessionId && job.status === 'processed') {\n        const record: SessionRecord = {\n          sessionId: job.sessionId,\n          status: 'processed',\n          title: job.sessionTitle || null,\n          eventCount: job.eventCount,\n          addedToCalendar: false,\n          eventSummaries: (job.events || []).slice(0, 3).map((e) => e.summary),\n          events: job.events || [],\n          createdAt: job.createdAt,\n          inputType: 'text',\n        };\n        addSessionRecord(record).then(() => {\n          storage.session.remove('activeJob', () => resolve());\n        });\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\n// ===== Context Menu Click Handler =====\n\napi.contextMenus.onClicked.addListener(async (info) => {\n  if (info.menuItemId !== CONTEXT_MENU_ID) return;\n\n  const hasAuth = await ensureAuth();\n  if (!hasAuth) return;\n\n  try {\n    let session;\n    let inputType: SessionRecord['inputType'] = 'text';\n\n    if (info.selectionText) {\n      setBadgeProcessing();\n      session = await createTextSession(info.selectionText);\n      inputType = 'text';\n    } else if (info.srcUrl) {\n      setBadgeProcessing();\n      session = await uploadImage(info.srcUrl);\n      inputType = 'image';\n    } else {\n      return;\n    }\n\n    const record: SessionRecord = {\n      sessionId: session.id,\n      status: 'polling',\n      title: null,\n      eventCount: 0,\n      addedToCalendar: false,\n      eventSummaries: [],\n      events: [],\n      createdAt: Date.now(),\n      inputType,\n    };\n    await addSessionRecord(record);\n\n    startPolling(session.id);\n  } catch (error) {\n    console.error('DropCal: Failed to create session', error);\n    const msg = error instanceof Error ? error.message : 'Unknown error';\n    const msgLower = msg.toLowerCase();\n    const isAuthError =\n      msgLower.includes('401') || msgLower.includes('403') ||\n      msgLower.includes('authentication') || msgLower.includes('jwt') ||\n      msgLower.includes('token') || msgLower.includes('expired');\n\n    setBadgeError();\n    setTimeout(() => syncBadge(), 5000);\n\n    if (isAuthError) {\n      await clearAuth();\n    }\n  }\n});\n\n// ===== Polling Logic =====\n\n// Track poll start times for timeout detection\nconst pollStartTimes = new Map<string, number>();\n\nonPollTick(async (sessionId) => {\n  if (!pollStartTimes.has(sessionId)) {\n    pollStartTimes.set(sessionId, Date.now());\n  }\n\n  const startTime = pollStartTimes.get(sessionId)!;\n\n  if (Date.now() - startTime > MAX_POLL_DURATION_MS) {\n    stopPolling(sessionId);\n    pollStartTimes.delete(sessionId);\n    await updateSessionRecord(sessionId, {\n      status: 'error',\n      errorMessage: 'Processing timed out. Please try again.',\n    });\n    await pushNotification(sessionId);\n    return;\n  }\n\n  try {\n    const session = await getSession(sessionId);\n\n    if (session.status === 'processed') {\n      stopPolling(sessionId);\n      pollStartTimes.delete(sessionId);\n\n      const { events, count } = await getSessionEvents(sessionId);\n\n      await updateSessionRecord(sessionId, {\n        status: 'processed',\n        title: session.title || null,\n        icon: session.icon || null,\n        eventCount: count,\n        addedToCalendar: session.added_to_calendar,\n        eventSummaries: events.slice(0, 3).map((e) => e.summary),\n        events,\n      });\n      await pushNotification(sessionId);\n\n      notifications.create(`dropcal-${sessionId}`, {\n        type: 'basic',\n        iconUrl: 'icons/icon128.png',\n        title: 'DropCal',\n        message: count === 1 ? '1 event scheduled' : `${count} events scheduled`,\n      });\n\n      action.tryOpenPopup();\n      return;\n    }\n\n    if (session.status === 'error') {\n      stopPolling(sessionId);\n      pollStartTimes.delete(sessionId);\n      await updateSessionRecord(sessionId, {\n        status: 'error',\n        errorMessage: session.error_message || 'Processing failed',\n      });\n      await pushNotification(sessionId);\n      return;\n    }\n\n    // Update title and icon mid-processing if available\n    const midUpdates: Partial<SessionRecord> = {};\n    if (session.title) midUpdates.title = session.title;\n    if (session.icon) midUpdates.icon = session.icon;\n    if (Object.keys(midUpdates).length > 0) {\n      await updateSessionRecord(sessionId, midUpdates);\n    }\n  } catch (error) {\n    console.error('DropCal: Poll error', error);\n    // Don't stop \u2014 let the next tick retry\n  }\n});\n\n// ===== Badge Helpers =====\n\nlet badgeSpinnerInterval: ReturnType<typeof setInterval> | null = null;\n\nfunction setBadgeProcessing(): void {\n  if (badgeSpinnerInterval !== null) return; // already spinning\n  const frames = ['\u280B', '\u2819', '\u2839', '\u2838', '\u283C', '\u2834', '\u2826', '\u2827', '\u2807', '\u280F'];\n  let i = 0;\n  action.setBadgeBackgroundColor({ color: '#1170C5' });\n  action.setBadgeText({ text: frames[0] });\n  badgeSpinnerInterval = setInterval(() => {\n    i = (i + 1) % frames.length;\n    action.setBadgeText({ text: frames[i] });\n  }, 350);\n}\n\nfunction clearBadgeSpinner(): void {\n  if (badgeSpinnerInterval !== null) {\n    clearInterval(badgeSpinnerInterval);\n    badgeSpinnerInterval = null;\n  }\n}\n\nfunction setBadgeCount(count: number): void {\n  clearBadgeSpinner();\n  action.setBadgeText({ text: String(count) });\n  action.setBadgeBackgroundColor({ color: '#2e7d32' });\n}\n\nfunction setBadgeError(): void {\n  clearBadgeSpinner();\n  action.setBadgeText({ text: '!' });\n  action.setBadgeBackgroundColor({ color: '#c41e3a' });\n}\n\nfunction clearBadge(): void {\n  clearBadgeSpinner();\n  action.setBadgeText({ text: '' });\n}\n\n// Derives badge state from notification queue + session history.\nasync function syncBadge(): Promise<void> {\n  const [history, queue] = await Promise.all([getHistory(), getNotificationQueue()]);\n  const sessions = history.sessions;\n\n  // Any session still polling \u2192 spinner\n  if (sessions.some((s) => s.status === 'polling')) {\n    setBadgeProcessing();\n    return;\n  }\n\n  // Check pending notifications for errors and event counts\n  let totalEvents = 0;\n  let hasError = false;\n  for (const id of queue) {\n    const s = sessions.find((r) => r.sessionId === id);\n    if (!s || s.dismissedAt || Date.now() - s.createdAt > FEEDBACK_EXPIRY_MS) continue;\n\n    if (s.status === 'error' || (s.status === 'processed' && s.eventCount === 0)) {\n      hasError = true;\n    } else if (s.status === 'processed') {\n      totalEvents += s.eventCount;\n    }\n  }\n\n  if (hasError) {\n    setBadgeError();\n    return;\n  }\n\n  if (totalEvents > 0) {\n    setBadgeCount(totalEvents);\n    return;\n  }\n\n  // Default: clear\n  clearBadge();\n}\n\n// ===== Message Handler =====\n\napi.runtime.onMessage.addListener((message, _sender, sendResponse) => {\n  // Content script sends auth token from dropcal.ai\n  if (message.type === 'AUTH_TOKEN') {\n    const { accessToken, refreshToken, expiresAt } = message;\n    setAuth({ accessToken, refreshToken, expiresAt }).then(() => {\n      sendResponse({ ok: true });\n    });\n    return true;\n  }\n\n  // Content script sends theme mode changes from dropcal.ai\n  if (message.type === 'THEME_CHANGED') {\n    const themeMode = message.themeMode || 'auto';\n    storage.local.set({ themeMode });\n    sendResponse({ ok: true });\n    return false;\n  }\n\n  if (message.type === 'AUTH_SIGNED_OUT') {\n    clearAuth().then(() => sendResponse({ ok: true }));\n    return true;\n  }\n\n  // Popup queries\n  if (message.type === 'GET_STATUS') {\n    Promise.all([\n      new Promise<Record<string, any>>((resolve) => {\n        storage.session.get('activeJob', resolve);\n      }),\n      getAuth(),\n    ]).then(([jobResult, auth]) => {\n      sendResponse({ job: jobResult.activeJob || null, isAuthenticated: !!auth });\n    });\n    return true;\n  }\n\n  if (message.type === 'GET_AUTH') {\n    getAuth().then((auth) => {\n      sendResponse({ isAuthenticated: !!auth });\n    });\n    return true;\n  }\n\n  if (message.type === 'SIGN_IN') {\n    const heading = encodeURIComponent('Sign in to start creating events.');\n    api.tabs.create({ url: `${DROPCAL_URL}/?auth=${heading}` });\n    sendResponse({ ok: true });\n    return false;\n  }\n\n  if (message.type === 'OPEN_SESSION') {\n    const { sessionId } = message;\n    const url = `${DROPCAL_URL}/s/${sessionId}`;\n    api.tabs.create({ url });\n    sendResponse({ ok: true });\n    return false;\n  }\n\n  if (message.type === 'CLEAR_JOB') {\n    storage.session.remove('activeJob');\n    clearBadge();\n    sendResponse({ ok: true });\n    return false;\n  }\n\n  if (message.type === 'SUBMIT_TEXT') {\n    const { text } = message;\n    ensureAuth().then(async (hasAuth) => {\n      if (!hasAuth) {\n        sendResponse({ ok: false, error: 'Not authenticated' });\n        return;\n      }\n      try {\n        setBadgeProcessing();\n        const session = await createTextSession(text);\n        const record: SessionRecord = {\n          sessionId: session.id,\n          status: 'polling',\n          title: null,\n          eventCount: 0,\n          addedToCalendar: false,\n          eventSummaries: [],\n          events: [],\n          createdAt: Date.now(),\n          inputType: 'text',\n        };\n        await addSessionRecord(record);\n        startPolling(session.id);\n        sendResponse({ ok: true });\n      } catch (error) {\n        console.error('DropCal: Submit text failed', error);\n        clearBadge();\n        sendResponse({ ok: false });\n      }\n    });\n    return true;\n  }\n\n  // Popup uploads files directly via fetch, then sends this to start polling\n  if (message.type === 'TRACK_SESSION') {\n    const { sessionId, inputType } = message;\n    setBadgeProcessing();\n    const record: SessionRecord = {\n      sessionId,\n      status: 'polling',\n      title: null,\n      eventCount: 0,\n      addedToCalendar: false,\n      eventSummaries: [],\n      events: [],\n      createdAt: Date.now(),\n      inputType: inputType || 'file',\n    };\n    addSessionRecord(record).then(() => {\n      startPolling(sessionId);\n      sendResponse({ ok: true });\n    });\n    return true;\n  }\n\n  if (message.type === 'GET_HISTORY') {\n    getHistory().then((history) => {\n      sendResponse({ sessions: history.sessions });\n    });\n    return true;\n  }\n\n  // Sidebar\n  if (message.type === 'OPEN_SIDEBAR') {\n    const { sessionId } = message;\n    api.windows.getLastFocused().then((window) => {\n      if (window.id) {\n        panel.open({ windowId: window.id, sessionId }).catch(() => {});\n      }\n    });\n    sendResponse({ ok: true });\n    return false;\n  }\n\n  // Settings \u2014 get full user profile\n  if (message.type === 'GET_USER_PROFILE') {\n    ensureAuth().then(async (hasAuth) => {\n      if (!hasAuth) {\n        sendResponse({ ok: false, error: 'Not authenticated' });\n        return;\n      }\n      try {\n        const profile = await getUserProfile();\n        sendResponse({ ok: true, profile });\n      } catch (error) {\n        console.error('DropCal: Failed to get profile', error);\n        sendResponse({ ok: false, error: 'Failed to load profile' });\n      }\n    });\n    return true;\n  }\n\n  // Settings \u2014 update preferences (theme_mode, date_format)\n  if (message.type === 'UPDATE_PREFERENCES') {\n    ensureAuth().then(async (hasAuth) => {\n      if (!hasAuth) {\n        sendResponse({ ok: false, error: 'Not authenticated' });\n        return;\n      }\n      try {\n        const result = await updateUserPreferences(message.preferences);\n        // If theme_mode was updated, also update local storage for immediate theme change\n        if (message.preferences.theme_mode) {\n          storage.local.set({ themeMode: message.preferences.theme_mode });\n        }\n        sendResponse({ ok: true, preferences: result.preferences });\n      } catch (error) {\n        console.error('DropCal: Failed to update preferences', error);\n        sendResponse({ ok: false, error: 'Failed to save preferences' });\n      }\n    });\n    return true;\n  }\n\n  // Settings \u2014 get calendar providers\n  if (message.type === 'GET_CALENDAR_PROVIDERS') {\n    ensureAuth().then(async (hasAuth) => {\n      if (!hasAuth) {\n        sendResponse({ ok: false, error: 'Not authenticated' });\n        return;\n      }\n      try {\n        const result = await getCalendarProviders();\n        sendResponse({ ok: true, providers: result.providers });\n      } catch (error) {\n        console.error('DropCal: Failed to get providers', error);\n        sendResponse({ ok: false, error: 'Failed to load providers' });\n      }\n    });\n    return true;\n  }\n\n  // Settings \u2014 set primary calendar provider\n  if (message.type === 'SET_PRIMARY_PROVIDER') {\n    ensureAuth().then(async (hasAuth) => {\n      if (!hasAuth) {\n        sendResponse({ ok: false, error: 'Not authenticated' });\n        return;\n      }\n      try {\n        await setPrimaryCalendarProvider(message.provider);\n        sendResponse({ ok: true });\n      } catch (error) {\n        console.error('DropCal: Failed to set primary', error);\n        sendResponse({ ok: false, error: 'Failed to set primary provider' });\n      }\n    });\n    return true;\n  }\n\n  // Settings \u2014 disconnect calendar provider\n  if (message.type === 'DISCONNECT_PROVIDER') {\n    ensureAuth().then(async (hasAuth) => {\n      if (!hasAuth) {\n        sendResponse({ ok: false, error: 'Not authenticated' });\n        return;\n      }\n      try {\n        await disconnectCalendarProvider(message.provider);\n        sendResponse({ ok: true });\n      } catch (error) {\n        console.error('DropCal: Failed to disconnect', error);\n        sendResponse({ ok: false, error: 'Failed to disconnect provider' });\n      }\n    });\n    return true;\n  }\n\n  // Popup \u2014 dismiss session feedback\n  if (message.type === 'DISMISS_SESSION') {\n    const { sessionId } = message;\n    Promise.all([\n      removeNotification(sessionId),\n      updateSessionRecord(sessionId, { dismissedAt: Date.now() }),\n    ]).then(() => {\n      sendResponse({ ok: true });\n    });\n    return true;\n  }\n\n  // Sidebar \u2014 push all session events to calendar\n  if (message.type === 'PUSH_ALL_EVENTS') {\n    const { sessionId } = message;\n    (async () => {\n      const hasAuth = await ensureAuth();\n      if (!hasAuth) return { ok: false, error: 'Not authenticated' };\n\n      const history = await getHistory();\n      const session = history.sessions.find((s) => s.sessionId === sessionId);\n      const eventIds = (session?.events || [])\n        .map((e) => e.id)\n        .filter((id): id is string => !!id);\n\n      if (eventIds.length === 0) return { ok: false, error: 'No events to add' };\n\n      const result = await pushEvents(sessionId, eventIds);\n      if (result.success) {\n        await updateSessionRecord(sessionId, { addedToCalendar: true });\n      }\n      return { ok: result.success, message: result.message };\n    })()\n      .then((resp) => sendResponse(resp))\n      .catch((error) => {\n        console.error('DropCal: Push events failed', error);\n        sendResponse({ ok: false, error: 'Failed to add events to calendar' });\n      });\n    return true;\n  }\n\n  // Settings \u2014 sign out (user-initiated)\n  if (message.type === 'SIGN_OUT') {\n    clearAuth().then(() => {\n      sendResponse({ ok: true });\n    });\n    return true;\n  }\n\n  return false;\n});\n\n// ===== Notification Click =====\n\nnotifications.onClicked.addListener(async (notificationId: string) => {\n  if (!notificationId.startsWith('dropcal-')) return;\n  const sessionId = notificationId.replace('dropcal-', '');\n  storage.session.set({ sidebarSessionId: sessionId });\n  // Notification click is a user gesture \u2014 open session in DropCal instead\n  // (sidePanel.open from service worker without user gesture context is unreliable)\n  const url = `${DROPCAL_URL}/s/${sessionId}`;\n  api.tabs.create({ url });\n});\n"],
  "mappings": "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",
  "names": ["API_URL", "_authToken", "setAuthToken", "token", "authHeaders", "headers", "handleResponse", "response", "err", "createTextSession", "text", "uploadImage", "imageUrl", "imageResponse", "blob", "filename", "formData", "getSession", "sessionId", "getSessionEvents", "getUserPreferences", "getUserProfile", "data", "updateUserPreferences", "prefs", "getCalendarProviders", "setPrimaryCalendarProvider", "provider", "disconnectCalendarProvider", "pushEvents", "eventIds", "_chrome", "hasNativeBrowserAPI", "api", "hasSidePanel", "hasSidebarAction", "hasSessionStorage", "hasNotifications", "hasOpenPopup", "hasAlarms", "SESSION_PREFIX", "prefixKeys", "keys", "k", "prefixRecord", "items", "out", "v", "unprefixRecord", "result", "sessionFallbackListeners", "localChangeListenerInstalled", "ensureLocalChangeListener", "api", "changes", "sessionChanges", "hasChanges", "key", "change", "listener", "sessionFallback", "callback", "prefixed", "all", "sessionKeys", "clearSessionFallback", "hasSessionStorage", "wrapNativeSession", "native", "storage", "notifications", "id", "options", "hasNotifications", "api", "_cb", "chromeSidePanel", "windowId", "sessionId", "resolve", "storage", "api", "firefoxSidebar", "panel", "hasSidePanel", "action", "details", "api", "hasOpenPopup", "POLL_PERIOD_MINUTES", "RAPID_POLL_MS", "KEEPALIVE_ALARM", "pollCallback", "activePolls", "rapidTimers", "onPollTick", "callback", "hasAlarms", "api", "alarm", "startPolling", "sessionId", "ensureKeepalive", "scheduleRapidPoll", "stopPolling", "timer", "clearKeepalive", "scheduleRapidPoll", "sessionId", "activePolls", "tick", "pollCallback", "rapidTimers", "RAPID_POLL_MS", "ensureKeepalive", "hasAlarms", "api", "KEEPALIVE_ALARM", "alarm", "clearKeepalive", "MAX_POLL_DURATION_MS", "MAX_HISTORY_SESSIONS", "CONTEXT_MENU_ID", "DROPCAL_URL", "FEEDBACK_EXPIRY_MS", "clearSessionFallback", "getAuth", "resolve", "storage", "result", "setAuth", "auth", "setAuthToken", "fetchAndStoreTheme", "themeMode", "getUserPreferences", "clearAuth", "ensureAuth", "getHistory", "saveHistory", "history", "syncBadge", "addSessionRecord", "record", "s", "updateSessionRecord", "sessionId", "updates", "idx", "getNotificationQueue", "saveNotificationQueue", "queue", "pushNotification", "removeNotification", "id", "api", "migratePhase1Job", "job", "e", "info", "session", "inputType", "setBadgeProcessing", "createTextSession", "uploadImage", "startPolling", "error", "msgLower", "isAuthError", "setBadgeError", "pollStartTimes", "onPollTick", "startTime", "stopPolling", "getSession", "events", "count", "getSessionEvents", "notifications", "action", "midUpdates", "badgeSpinnerInterval", "frames", "i", "clearBadgeSpinner", "setBadgeCount", "clearBadge", "sessions", "totalEvents", "hasError", "r", "message", "_sender", "sendResponse", "accessToken", "refreshToken", "expiresAt", "jobResult", "heading", "url", "text", "hasAuth", "window", "panel", "profile", "getUserProfile", "updateUserPreferences", "getCalendarProviders", "setPrimaryCalendarProvider", "disconnectCalendarProvider", "eventIds", "pushEvents", "resp", "notificationId"]
}
